//=========================================//
//                                         //
// RUPTURE: better breakpoints for Stylus  //
//                                         //
//=========================================//

// conditionally assign common globals
base-font-size          ?= 16px
rasterise-media-queries ?= false

// base settings
rupture = {
  rasterise-media-queries : rasterise-media-queries
  mobile-cutoff           : 400px
  desktop-cutoff          : 1050px
  hd-cutoff               : 1800px
  enable-em-breakpoints   : false
  base-font-size          : base-font-size
  anti-overlap            : false
  density-queries         : 'dppx' 'webkit' 'moz' 'dpi'
  retina-density          : 1.5
  use-device-width        : false
  scale                   : ()
  scale-names             : ()
}

// dictionary map of scale names to scale values
rupture.scale-map = {
  'xs' : 0
  's'  : (rupture.mobile-cutoff)
  'm'  : 600px
  'l'  : 800px
  'xl' : (rupture.desktop-cutoff)
  'hd' : (rupture.hd-cutoff)
}

// dynamically split the scale map into separate lists
for scale-names, scale in rupture.scale-map
  push(rupture[prop], lookup(prop)) for prop in ('scale' 'scale-names')

// checks if value is string or identifier
// @type Function
// @api private
// @param {Mixed} value - any data type
// @return {Boolean} - true if value is stringish
-is-string(value)
  typeof(value) is not 'unit' and (value is a 'string' or value is a 'ident')

// gets the associated scale measure for a given scale name
// @type Function
// @api private
// @param {String} scale-name - the name of a point on the scale
// @return {Number|Boolean} - the scale measure or false if one was not found
-get-scale-number(scale-name)
  return n + 1 if item is scale-name for item, n in rupture.scale-names
  return false

// converts from one unit to another unit, e.g. px -> em
// @type Function
// @api private
// @param {String} to-unit - the unit to be converted to
// @param {Unit} value - the value you want to convert
// @param {Unit} [context] - the context in which to convert
// @return {Unit} - the final converted value
-convert-to(
  to-unit = null,
  value   = null,
  context = rupture.base-font-size
)
  from-unit = unit(value)
  return value if to-unit is from-unit
  if to-unit in ('em' 'rem')
    return value if from-unit in ('em' 'rem')
    return unit((value / context), to-unit)
  if to-unit is 'px'
    return unit((value * context), 'px')

// checks if a number is a scale measure by assuming that unitless = on scale
// @type Function
// @api private
// @param {Number} - the number to check
// @return {Boolean} - true if so or false otherwise
-on-scale(n)
  return unit(n) is ''

// checks if a number is larger than any number on the scale
// @type Function
// @api private
// @param {Number} n - the number to check
// @return {Boolean} - true if larger than scale, otherwise false
-larger-than-scale(n)
  return (n > (length(rupture.scale) - 1)) and -on-scale(n)

// simply a functional alias to check if a number is 0
// @type Function
// @api private
// @param {Number} n - the number to check
// @return {Boolean} - true if the number is 0
-is-zero(n)
  return n is 0

// shifts the given value to account for scale overlap
// @type Function
// @api private
// @param {Boolean} anti-overlap - whether to prevent overlap
// @param {Number} n - the value
// @return {Unit} - the newly shifted value
-overlap-shift(
  anti-overlap = null,
  n            = null
)
  shift-unit   = unit(n)
  anti-overlap = 0px unless anti-overlap
  anti-overlap = 1px if anti-overlap is true
  return -convert-to(shift-unit, anti-overlap) if length(anti-overlap) is 1
  return val if unit(val) is shift-unit for val in anti-overlap

// adjusts size values to account for scale overlap
// @type Function
// @api private
// @param {Boolean} anti-overlap - whether to prevent overlap
// @param {Number} n - the value
// @param {String} side - whether this is a "min" or "max" query
// @return {Number} - the newly adjusted value
-adjust-overlap(
  anti-overlap = null,
  n            = null,
  side         = 'min'
)
  -shift = -overlap-shift(anti-overlap, n)
  if (side is 'min' and -shift > 0) or (side is 'max' and -shift < 0)
    n = n + -shift
  return n

// checks if a given number is not negative
// @type Function
// @api private
// @param {Number} n - the number to check
// @return {Boolean} - true if positive
-is-positive(n)
  return n >= 0

// normalizes media query densities for different browser vendors
// @type Function
// @api private
// @param {Number} density
// @return {String} - the normalized queries
-density-queries(density)
  if (typeof(density) is not 'unit') and (not -is-string(density))
    density = '%s' % density
  density = rupture.retina-density if density is 'retina'
  queries = ()
  dpr     = 'device-pixel-ratio'
  query-map = {
    'webkit': '-webkit-min'
    'moz'   : 'min--moz'
    'o'     : '-o-min'
  }
  for query in rupture.density-queries
    if query is 'webkit' or query is 'moz' or query is 'o'
      density = query is 'o' ? '%s/1' % (density) : density
      new-query = s('(%s-%s: %s)', s(query-map[query]), s(dpr), density)
      push(queries, new-query)
    else if query is 'dpi'
      density = -convert-string-to-node(density)
      push(queries, '(min-resolution: %sdpi)' % (round(density * 96, 1)))
    else if query is 'dppx'
      push(queries, '(min-resolution: %sdppx)' % (density))
  return queries

// converts a string to a stylus node if it is stringish
// @type Function
// @api private
// @param {String} str - the string to convert
// @return {Node} - the converted node
-convert-string-to-node(str)
  return -is-string(str) ? convert(str) : str

// converts a string to a number on the scale
// @type Function
// @api private
// @param {String} str - the string to convert
// @return {Number} - the converted scale number
-convert-string-to-scale-number(str)
  return -is-string(str) ? -get-scale-number(str) : str

// creates a fall back class with the specified block of stylus
// @type BlockMixin
// @api private
// @param {Selector} selected - the CSS selector
// @param {String} class - the CSS class to create a fallback for
// @param {Block} block - the block of code
create-fallback-class(
  selected = null,
  class    = null,
  block    = block
)
  /{class + ' ' + selected}
    {block}

// ensures a fallback class by checking if class is defined
// @type Mixin
// @api private
ensure-fallback-class(selected, class, block = block)
  create-fallback-class(selected, class, block) if class

// creates a media query that targets a range between two specified measures
// @type BlockMixin
// @api public
between(
  min              = null,
  max              = null,
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  density     = -convert-string-to-node(density)
  orientation = -convert-string-to-node(orientation)

  min = -convert-string-to-scale-number(min)
  max = -convert-string-to-scale-number(max)

  -min  = rupture.scale[min - 1] unless -is-zero(min) or (not -on-scale(min))
  -max  = rupture.scale[max] unless not -on-scale(max)
  -min ?= min
  -max ?= max

  if (rupture.rasterise-media-queries)
    {block} if not (density or -max or orientation)
  else
    condition        = 'only screen'
    use-device-width = use-device-width ? 'device-' : ''
    unless -min is 0
      -min = -convert-to('em', -min) if rupture.enable-em-breakpoints
      -min = -adjust-overlap(anti-overlap, -min, side: 'min')
      condition += ' and (min-' + use-device-width + 'width: %s)' % (-min)
    unless -larger-than-scale(max)
      -max = -convert-to('em', -max) if rupture.enable-em-breakpoints
      -max = -adjust-overlap(anti-overlap, -max, side: 'max')
      condition += ' and (max-' + use-device-width + 'width: %s)' % (-max)
    if orientation
      condition += ' and (orientation: %s)' % (orientation)
    if density
      conditions = ()
      for query in -density-queries(density)
        push(conditions, condition + ' and %s' % (query))
      condition = join(', ', conditions)
    @media condition
      {block}
  ensure-fallback-class(selector(), fallback-class, block)

// creates a media query that targets the range between the two measures
// surrounding a specified index on the scale
// @type BlockMixin
// @api public
at(
  scale-point      = null,
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  between(
    scale-point,
    scale-point,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets anything above a specified measure
// @type BlockMixin
// @api public
from-width(
  scale-point      = null,
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  between(
    scale-point,
    length(rupture.scale),
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets anything below a specified measure
// @type BlockMixin
// @api public
to-width(
  scale-point      = null,
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  between(
    1,
    scale-point,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets everything below the mobile cutoff measure
// @type BlockMixin
// @api public
mobile(
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  below(
    rupture.mobile-cutoff,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets everything between the mobile cutoff and
// desktop cutoff measures
// @type BlockMixin
// @api public
tablet(
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  between(
    rupture.mobile-cutoff,
    rupture.desktop-cutoff,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets everything above the desktop cutoff
// measure
// @type BlockMixin
// @api public
desktop(
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  above(
    rupture.desktop-cutoff,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets everything above the HD cutoff measure
// @type BlockMixin
// @api public
hd(
  anti-overlap     = rupture.anti-overlap,
  density          = null,
  orientation      = null,
  use-device-width = rupture.use-device-width,
  fallback-class   = null,
  block            = block
)
  orientation = -convert-string-to-node(orientation)
  density     = -convert-string-to-node(density)
  above(
    rupture.hd-cutoff,
    anti-overlap,
    density,
    orientation,
    use-device-width,
    fallback-class,
    block
  )

// creates a media query that targets a specific screen density
// @type BlockMixin
// @api public
density(
  density        = null,
  orientation    = null,
  fallback-class = null,
  block          = block
)
  if not (rupture.rasterise-media-queries)
    conditions = ()
    for query in -density-queries(density)
      condition = 'only screen and %s' % (query)
      if orientation
        condition = condition + ' and (orientation: %s)' % (orientation)
      push(conditions, condition)
    condition = join(', ', conditions)
    @media condition
      {block}
    ensure-fallback-class(selector(), fallback-class, block)

// a quick shorthand for retina density media queries
// @type BlockMixin
// @api public
retina(
  orientation    = null,
  fallback-class = null,
  block          = block
)
  density('retina', orientation, fallback-class, block)

// creates a media query that targets landscape orientation
// @type BlockMixin
// @api public
landscape(
  density        = null,
  fallback-class = null,
  block          = block
)
  if not (rupture.rasterise-media-queries)
    density = -convert-string-to-node(density)
    if density
      pixel-ratio(density, orientation: landscape, fallback-class, block)
    else
      @media only screen and (orientation: landscape)
        {block}
      ensure-fallback-class(selector(), fallback-class, block)

// creates a media query that targets portrait orientation
// @type BlockMixin
// @api public
portrait(
  density        = null,
  fallback-class = null,
  block          = block
)
  if not (rupture.rasterise-media-queries)
    density = -convert-string-to-node(density)
    if density
      pixel-ratio(density, orientation: portrait, fallback-class, block)
    else
      @media only screen and (orientation: portrait)
        {block}
      ensure-fallback-class(selector(), fallback-class, block)

// aliases
pixel-ratio = density
below       = to-width
above       = from-width
